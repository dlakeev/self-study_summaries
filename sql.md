# With as
Используется для того, чтобы "запаковать" запрос.
### Пример
```sql
WITH AS name_ as (
    SELECT *
    from table_name
)

SELECT *
from name_
```
___
# Пересечение множеств
## Join

<p align="center">
  <img src="https://www.postgresqltutorial.com/wp-content/uploads/2018/12/PostgreSQL-Joins.png">
</p>

___
## Другие
* **_UNION_** по сути добавляет результаты второго запроса к результатам первого (хотя никакой порядок возвращаемых строк при этом не гарантируется). Более того, эта операция убирает дублирующиеся строки из результата так же, как это делает DISTINCT, если только не указано UNION ALL.

* **_INTERSECT_** возвращает все строки, содержащиеся в результате и первого, и второго запроса. Дублирующиеся строки отфильтровываются, если не указано ALL.

* **_EXCEPT_** возвращает все строки, которые есть в результате первого запроса, но отсутствуют в результате второго. (Иногда это называют разницей двух запросов.) И здесь дублирующиеся строки отфильтровываются, если не указано ALL.
___

# Оконные функции
**_Оконными_** называют функции, которые обрабатывают выделенные наборы строк (окна или партиции) и записывают результаты вычислений в отдельном столбце.

В отличие от ```group by```, с которым на выходе вместо исходного набора возвращается одна строка с результатом, оконные функции возвращают ровно те записи, которые получили на вход — просто в «расширенном» виде.

Определяются окна с помощью инструкции ```OVER()``` — в общем виде её синтаксис выглядит так:

<p align="center">
  <img src="https://sun9-74.userapi.com/impg/orD5u89hAO5ElCSEQ2ihIK0tXsPQCxy7tUcEVQ/T9a9ltN554c.jpg?size=807x224&quality=95&sign=cb413d3463e964d9f6f62bde59742b0e&type=album">
</p>

### PARTITION BY
определяет столбец, по которому данные будут делиться на партиции. Например, _user_id_ для группировки по пользователям, чтобы для каждой записи в таблице вычислить и вписать в столбец _sum_ общую сумму **ВСЕХ** покупок данного пользователя:

```sql
SUM(price) OVER (PARTITION BY user_id) AS 'sum'
```

<p align="center">
  <img src="https://sun9-23.userapi.com/impg/xKnR7Ba6b00rhlgEyGFzojivWwBdk9r-IX1lqw/3GHrfYl6NGA.jpg?size=807x217&quality=95&sign=4e7a24a11337e258f3ceb30ee79672dd&type=album">
</p>

### ORDER BY

определяет столбец, по которому значения внутри окна будут сортироваться при обработке. Сортировка позволяет получить вместо общего результата - нарастающий. Например, _date_ для сортировки по хронологии, чтобы для каждой записи в таблице вычислить и вписать в столбец _sum_ сумму **ТЕКУЩЕЙ** и **ВСЕХ ПРЕДЫДУЩИХ** покупок пользователя:

```sql
SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS 'sum'
```

<p align="center">
  <img src="https://sun9-63.userapi.com/impg/RBTr4uzY6prnyzqbv4vULiTGHDsf25PrM7hhhw/XiyHUd3qE8M.jpg?size=807x225&quality=95&sign=bbb9c18b56c769cbc711c577372d2264&type=album">
</p>

### ROWS / RANGE

могут дополнительно ограничивать диапазон работы функций внутри партиции. Пример, где для каждой записи в таблице вычисляется и пишется в столбец _sum_ сумма **ТЕКУЩЕЙ** и **ПРЕДЫДУЩЕЙ** покупки пользователя:

```sql
SUM(price) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS 'sum'
```

<p align="center">
  <img src="https://sun9-46.userapi.com/impg/LcnTDcbq-s5NycIzifBffNdc8bGFgXaKH_-c1Q/4TadXCaJUNU.jpg?size=807x216&quality=95&sign=38942b164355101c0658421a57b614e1&type=album">
</p>

### Виды оконных функций
**_Агрегатные_**:
* ```SUM```
* ```AVG```
* ```MAX``` (```MIN)```
* ```COUNT```

**_Ранжирующие_** (для функций ранжирования всегда нужно прописывать ```ORDER BY```):
* ```ROW_NUMBER``` — простая нумерация (1, 2, 3, 4, 5)
* ```RANK``` — нумерация с учётом повторяющихся значений с пропуском рангов (1, 2, 2, 4, 5)
* ```DENSE_RANK``` — нумерация с учётом повторяющихся значений без пропуска рангов (1, 2, 2, 3, 4)

**_Функции смещения_** (для функций ранжирования всегда нужно прописывать ```ORDER BY```):
* ```LAG``` — значение предыдущей строки
* ```LEAD``` — значение следующей строки
* ```FIRST_VALUE```— первое значение в окне
* ```LAST_VALUE```— последнее значение в окне